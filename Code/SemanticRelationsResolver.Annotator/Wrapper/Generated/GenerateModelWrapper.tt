<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="$(SolutionDir)\Code\SemanticRelationsResolver.Domain\bin\Debug\SemanticRelationsResolver.Domain.dll" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Reflection" #>
<#@ import namespace="System.Collections" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="SemanticRelationsResolver.Domain" #>
<#@ output extension=".cs" #>
<#
	foreach(var modelType in GetModelTypes())
	{
		var simpleProperties = modelType.GetProperties(BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly).Where(p => p.PropertyType.IsValueType || p.PropertyType == typeof(string)).ToList();
		var complexProperties = modelType.GetProperties(BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly).Except(simpleProperties).Where(p => p.PropertyType.IsClass && !typeof(IEnumerable).IsAssignableFrom(p.PropertyType)).ToList();
		var collectionProperties = modelType.GetProperties(BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly).Except(simpleProperties).Except(complexProperties).Where(p => p.PropertyType.IsGenericType).ToList();
#>
namespace SemanticRelationsResolver.Annotator.Wrapper
{
	using System;
	using System.Linq;
	using Base;
	using SemanticRelationsResolver.Domain;

<#
		if(modelType.Name != "ModelBase")
		{
#>
	public partial class <#=modelType.Name#>Wrapper : ModelBaseWrapper<<#=modelType.Name#>>
	{
		public <#=modelType.Name#>Wrapper(<#=modelType.Name#> model) : base(model)
		{
		}
<#
		}
		else
		{
#>
	public class ModelBaseWrapper<T> : ModelWrapper<T>
	where T : ModelBase
	{
		public ModelBaseWrapper(T model) : base(model)
		{
        }
<#
		}
#>
<#
		GenerateSimpleProperties(simpleProperties);
		GenerateComplexProperties(complexProperties);
		GenerateCollectionProperties(collectionProperties);
		GenerateInitializeComplexProperties(modelType.Name, complexProperties);
		GenerateInitializeCollectionProperties(modelType.Name, collectionProperties);
#>
	}
}
<#
		SaveGeneratedCodeAsFile(modelType.Name+"Wrapper.g.cs");
	}
#>
<#+ 
	private IEnumerable<Type> GetModelTypes(){
		return typeof(ModelBase).Assembly.GetTypes();
	} 

	private void SaveGeneratedCodeAsFile(string filename)
    {
		string dir = Path.GetDirectoryName(Host.TemplateFile);

		string outputFilePath = Path.Combine(dir, filename);
		File.WriteAllText(outputFilePath, GenerationEnvironment.ToString());

		GenerationEnvironment.Clear();

    }

	private void GenerateSimpleProperties(IEnumerable<PropertyInfo> properties)
    {
		foreach(var property in properties)
        {
			var propertyType = GetTypeName(property.PropertyType);
			var propertyName = property.Name;
#>

		public <#=propertyType#> <#= propertyName#>
        {
            get { return GetValue<<#=propertyType#>>(); }
            set { SetValue(value); }
        }

        public <#=propertyType#> <#= propertyName#>OriginalValue
        {
            get { return GetOriginalValue<<#=propertyType#>>("<#= propertyName#>"); }
        }

        public bool <#= propertyName#>IsChanged
        {
            get { return GetIsChanged("<#= propertyName#>"); }
        }
<#+
        }
    }
#>
<#+
	private void GenerateComplexProperties(IEnumerable<PropertyInfo> properties)
    {
		foreach(var property in properties)
        {
			var propertyType = property.PropertyType.Name;
			var propertyName = property.Name;
#>

		public <#= propertyType #>Wrapper <#= propertyName#> { get;  private set; }
<#+
        }
    }
#>
<#+
	private void GenerateCollectionProperties(IEnumerable<PropertyInfo> properties)
    {
		foreach(var property in properties)
        {
			var propertyType = property.PropertyType.GenericTypeArguments.First().Name;
			var propertyName = property.Name;
#>

		public ChangeTrackingCollection<<#= propertyType #>Wrapper> <#= propertyName#> { get; set; }
<#+
        }
    }
#>
<#+
	private void GenerateInitializeComplexProperties(string modelTypeName, IEnumerable<PropertyInfo> properties)
	{
		if(properties.Any())
		{
#>

		protected override void InitializeComplexProperties(<#= modelTypeName #> model)
		{
<#+
			foreach(var property in properties)
			{
				var propertyName = property.Name;
				var propertyType = property.PropertyType.Name;
#>
			if(model.<#= propertyName #> == null)
			{
				throw new ArgumentException("<#= propertyName #> cannot be null.");
			}
			<#= propertyName #> = new <#= propertyType #>Wrapper(model.<#= propertyName #>);
			RegisterComplex(<#= propertyName #>);
<#+
			}
		}
	}
#>
<#+
	private void GenerateInitializeCollectionProperties(string modelTypeName, IEnumerable<PropertyInfo> properties)
	{
		if(properties.Any())
		{
#>

		protected override void InitializeCollectionProperties(<#= modelTypeName #> model)
		{
<#+
			foreach(var property in properties)
			{
				var propertyType = property.PropertyType.GenericTypeArguments.First().Name;
				var propertyName = property.Name;
#>
			if(model.<#= propertyName #> == null)
			{
				throw new ArgumentException("<#= propertyName #> cannot be null.");
			}
			<#= propertyName #> = new ChangeTrackingCollection<<#= propertyType #>Wrapper>(model.<#= propertyName #>.Select(e => new <#= propertyType #>Wrapper(e)));
			RegisterCollection(<#= propertyName #>, model.<#= propertyName #>);
<#+
			}
		#>
		}
<#+
	  }
	}
#>
<#+
	private string GetTypeName(Type type)
	{
		if(type.IsGenericType)
        {
			var genericArguments = type.GetGenericArguments().Select(t => GetTypeName(t)).ToArray();
			var typeDefinition = type.GetGenericTypeDefinition().FullName;
			typeDefinition = typeDefinition.Substring(0, typeDefinition.IndexOf('`'));

			return string.Format("{0}<{1}>", typeDefinition, string.Join(",", genericArguments));
        }
		else
		{
			return type.FullName;
        }
    }
#>